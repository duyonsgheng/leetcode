1.华为OD
 排序+二分，比如当前我需要接近的数为128，那么我的尝试的范围不会超过 -255到+255 ，那么中间取0，如果平均值 < 128，那么比0小的数不用尝试了
 二分，排序后，比如当前k=-16 那么我再数组中找到 <= 16最右的位置，那么这些位置全部为0。
 上限也是同样的道理。比如不超过50，当前k=30，那么我知道 >= 20最左的位置，这些位置上全部都是50.


2.动态规划
    一个字符串开头是B的时候，后面有几个R，就是f(n-1)递归去
    一个字符串开头是R的时候，后面有几个R呢，开始透视R，还剩下n-1个位置，那么就是2^(n-1)+f(n-1)，因为第一位已经被占用了，后面还有n-1个位置，每个位置两种选择所以2^(n-1)

    同余原理：加法和乘法的同余原理一样 (a+b)%mod = (a'+b')%mod，减法是(a'-b'+mod)%mod

    1.递归版本：从左往右尝试，当前位置和原字符串位置字符相同的时候，后面做决定，讨论当前位置是R还是B
    当前是R，那么只能直接往后继续调递归，且当前位置没有选择的余地，
    当前是B，后续就有两种选择，第一种当前位置继续是B，后续调用递归；第二种当前位置是R，那么后续就可以通过打表直接得到答案。


3.状态压缩的动态规划
    看数据量，16种课程，转化位信息，二进制位、
    把需要的课程转为一个数，每个人的技能按照技能的二进制位变成一个数。
    然后跑递归，要当前位置和不要当前位置，要了当前位置，就把当前人的信息或到status里面去往下传递。
    、

4.宽度优先遍历
    从当前位置出发到下一层，下一层要么全是奇数或者全是偶数。、