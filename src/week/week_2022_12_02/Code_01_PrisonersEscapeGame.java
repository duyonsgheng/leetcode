package week.week_2022_12_02;

/**
 * @ClassName Code_01_PrisonersEscapeGame
 * @Author Duys
 * @Description
 * @Date 2022/12/15 9:48
 **/
// 有100个犯人被关在监狱里，编号0~99
// 监狱长构思了一个处决犯人的计划
// 监狱长准备了100个盒子，每个盒子里面装有一个犯人的名字
// 一开始每个犯人都知道自己的盒子在哪
// 因为自己的编号，与盒子的编号一致，
// 这100个盒子排成一排，放在一个房间里面，盒子编号0~99，从左到右排列
// 监狱长彻底随机的打乱了盒子的排列，并且犯人并没有看到打乱的过程
// 监狱长规定，每个犯人依次进入房间，每个犯人都可以开启50个盒子，然后关上
// 每一个犯人全程无法进行任何交流，完全无法传递任何信息
// 监狱长规定，每个犯人在尝试50次的过程中，都需要找到自己的名字
// 如果有哪怕一个犯人没有做到这一点，100个罪犯全部处决
// 但是监狱长允许这个游戏开始之前，所有犯人在一起商量策略
// 请尽量制定一个让所有人存活概率最大的策略
// 来自论文<The Cell Probe Complexity of Succinct Data Structures>
// 作者Anna Gal和Peter Bro Miltersen写于2007年
// 如今该题变成了流行科普视频，我们来玩一玩
public class Code_01_PrisonersEscapeGame {
    // 编号0-99
    // 人也是0-99 打乱顺序，那么就是小标循环怼，看看大于等于51个点的环概率有多大

    /**
     * 环内节点有51 52.。。100 这些是必死的概率
     * 存活的概率就是 1-(P51+P52+....+P100)
     * 总共排列方式 100!
     * 当前节点有51的概率是 C(100,51) 排列组合 从100中选出51个，选出的这51个排列是 (51-1)!
     * 剩下的排列是 (100-51)!
     * 当前为r 那么就是 C(100,r) * (r-1)! * (100-r)! / 100!
     * 最后化简得到(1/r + 1/(r+1) + /1(r+2)+...+1/100)
     */
    public static double escape(int pepeo, int tryTimes) {
        double a = 0;
        for (int r = tryTimes + 1; r <= pepeo; r++) {
            a += (double) 1 / (double) r;
        }
        return 1.0 - a;
    }
}
