1.最长递增子序列问题的改写
    ends数组

2.三角形划分
    找终点，然后左右两边找去

3.
    排序+二分+前缀和

4.dp
    1.不用
    2.用一次
        1.不考虑i位置，那就是dp[i-1]+arr[i]
        2.考虑i位置，dp[0]...dp[i-1]谁大，就覆盖到哪里。要考虑一个位置都不要的时候是0的情况。
    3.用两次
        1.分割点，分割点的左右两边各用一次。

5.窗口
    a小窗口  a大窗口
    b小窗口  b大窗口
    那么达标的就是从同一个出发点到  max(a小,b小)到 min(a大,b大)这一段都是满足的

6.图
    入度为1的而且不是金币的点先减去，然后遍历图，分为核心点和非核心点，核心点的判别是距离金币点的距离 >= 2的点都是核心点。那么核心点一定会经过两次，其他的点只经过一次。