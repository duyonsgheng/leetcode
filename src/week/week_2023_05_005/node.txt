1.从目的地开始往能到的位置进行宽度优先便利，反着来

2.2560题
    经典的打家劫舍问题
    相邻数字不能拿，最大累加和
    dp[i]表示0到i位置上，相邻位置不能拿的最大累加和
    可能性1.i位置不拿，那么就p1=dp[i-1]
    可能性2.i位置拿，那么就是p2=dp[i-2]+arr[i]
    dp[i] =max(p1,p2);

    本题：使用二分，小偷的最小能力不会小于0 不会大于数组的max，然后每次跑一个上面的流程

3.coding的题

4.字符串hash
