package duys_code.day_10;

/**
 * @ClassName Code_03_Kq
 * @Author Duys
 * @Description 力扣：https://leetcode-cn.com/problems/k-inverse-pairs-array/
 * @Date 2021/10/14 15:25
 **/
public class Code_03_Kq {
    /**
     * 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。
     * 逆序对的定义如下：对于数组的第i个和第j个元素，如果满i<j且a[i]>a[j]，则其为一个逆序对；否则不是。
     * 由于答案可能很大，只需要返回 答案 mod 10^9+ 7 的值。
     * <p>
     * 提示：n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000] 有可能是一个 n*k的解。动态规划
     */

    // 样本对应模型
    // 比如 dp[5][3] -> 第5个值叫e，之前的叫abcd
    // 如果 j < i的时候，满足下面的递推
    // abcd [e] 如果e 来到最后的位置上，那么我要前边有几个逆序对了？3个，因为e都比前边的大，dp[4][3]
    // abc[e]d 如果e 来到倒数的第二位置上，那么我要前边有几个逆序对了？ed已经有1个了，那么要求前边有几个2个，dp[4][2]
    // ab[e]cd 如果e 来到倒数的第三位置上，那么我要前边有几个逆序对了？ecd已经有2个了，那么要求前边有几个2个，dp[4][1]
    // a[e]bcd 如果e 来到倒数的第四位置上，那么我要前边有几个逆序对了？ebcd已经有3个了，那么要求前边有几个3个，dp[4][0]
    // 不能在往前了，没了
    // dp[5][3] -> dp[4][3....0]
    // dp[5][4] -> dp[4][4....0] -> dp[5][4] = dp[4][4] + dp[5][3] ::: 斜率优化
    // 所以 j < i 的时候 dp[i][j] = dp[i-1][j] + dp[i][j-1]
    // -----------------------------------------
    // 当 j >= i 的时候，结果有点不一样，不能算到0了，比如dp[5][7]
    // 证明
    // abcd[e]  如果e 来到最后的位置上，那么我要前边有几个逆序对了？7个，因为e都比前边的大，dp[4][7]
    // abc[e]d  如果e 来到倒数的第二位置上，那么我要前边有几个逆序对了？6个，因为ed已经有1个了，dp[4][6]
    // ab[e]cd  如果e 来到倒数的第三位置上，那么我要前边有几个逆序对了？5个，因为ecd已经有2个了，dp[4][5]
    // a[e]bcd  如果e 来到倒数的第四位置上，那么我要前边有几个逆序对了？4个，因为ebcd已经有3个了，dp[4][4]
    // [e]abcd  如果e 来到倒数的第五位置上，那么我要前边有几个逆序对了？3个，因为eabcd已经有4个了，dp[4][3]
    // 没了
    // dp[5][7] -> dp[4][7....3]
    // dp[5][8] -> dp[4][8....4] -> dp[5][8] = dp[4][8]+dp[5][7] - dp[4][3]
    // 当 j>=i 的时候 dp[i][j] = dp[i-1][j]+dp[i][j-1] - dp[i-1][j-i]
    public static int kInversePairs(int n, int k) {
        if (n < 1 || k < 0) {
            return 0;
        }
        // dp
        int[][] dp = new int[n + 1][k + 1];
        // dp[i][j] 表示 1~i 这么多数字，正好有k个的逆序对 有几个不同的排列
        // 这里dp[i][0]表示0~i的数字形成0个逆序对答案是 1
        for (int i = 1; i <= n; i++) {
            dp[i][0] = 1;
        }
        int mod = 1000000007;
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;
                if (j >= i) {
                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;
                }
            }
        }
        return dp[n][k];
    }

    public static void main(String[] args) {
        System.out.println(kInversePairs(1000, 1000));
    }

}
