package duys.class_08_26;

/**
 * @ClassName DP_OPT_06
 * @Author Duys
 * @Description 四边形不等式 - 扔棋子或者扔鸡蛋问题(K-蛋问题) https://leetcode.com/problems/super-egg-drop
 * 楼层和棋子数作为样本的样本对应模型
 * @Date 2021/8/31 14:26
 **/
public class DP_OPT_06 {
    /**
     * 一座大楼有 0~N 层，地面算作第 0 层，最高的一层为第 N 层。已知棋子从第 0 层掉落肯定 不会摔碎，从第 i 层掉落可能会摔碎，
     * 也可能不会摔碎(1≤i≤N)。给定整数 N 作为楼层数， 再给定整数 K 作为棋子数，返 回如果想找到棋子不会摔碎的最高层数，
     * 即使在最差的情况下扔 的最少次数。一次只能扔一个棋子。
     * 【举例】
     * N=10，K=1。
     * 返回 10。因为只有 1 棵棋子，所以不得不从第 1 层开始一直试到第 10 层，在最差的情况 下，即第 10 层 是不会摔坏的最高层，最少也要扔 10 次。
     * N=3，K=2。
     * 返回 2。先在 2 层扔 1 棵棋子，如果碎了，试第 1 层，如果没碎，试第 3 层。 N=105，K=2 返回 14。
     * 第一个棋子先在 14 层扔，碎了则用仅存的一个棋子试 1~13。 若没碎，第一个棋子继续在 27 层扔，碎了则 用仅存的一个棋子试 15~26。 若没碎，
     * 第一个棋子继续在 39 层扔，碎了则用仅存的一个棋子试 28~38。 若 没碎，第一个棋子继续在 50 层扔，碎了则用仅存的一个棋子试 40~49。
     * 若没碎，第一个棋子继续在 60 层扔， 碎了则用仅存的一个棋子试 51~59。 若没碎，第一个棋子继续在 69 层扔，碎了则用仅存的一个棋子试 61~68。
     * 若没碎，第一个棋子继续在 77 层扔，碎了则用仅存的一个棋子试 70~76。 若没碎，第一个棋子继续在 84 层 扔，碎了则用仅存的一个棋子试 78~83。
     * 若没碎，第一个棋子继续在 90 层扔，碎了则用仅存的一个棋子试 85~89。 若没碎，第一个棋子继续在 95 层扔，碎了则用仅存的一个棋子试 91~94。
     * 若没碎，第一个棋子继续 在 99 层扔，碎了则用仅存的一个棋子试 96~98。 若没碎，第一个棋子继续在 102 层扔，碎了则用仅存的一 个棋子试 100、101。 若没碎，第一个棋子继续在 104 层扔，碎了则用仅存的一个棋子试 103。 若没碎，第 一个棋子继续在 105 层扔，若到这一步还没碎，那么 105 便是结果。
     */

    public static int superEggDrop1(int kChess, int nLevel) {
        if (kChess < 1 || nLevel < 1) {
            return 0;
        }
        return process1(nLevel, kChess);
    }

    // 什么含义：rest 就是还剩下多少层楼，k-棋子数
    public static int process1(int rest, int k) {
        if (rest == 0) {
            return 0;
        }
        // 如果只剩下了一颗棋子，那么就需要扔还剩下的楼层，因为不确定那一层会碎，所以需要扔rest次
        if (k == 1) {
            return rest;
        }
        int min = Integer.MAX_VALUE;
        for (int i = 1; i != rest + 1; i++) {
            // 如果碎了
            // 比如现在开始这个方法的时候rest总共20层楼，
            // 当前 i 来到第10层，扔下去碎了，(10 - 1) 那么去 1 - 9层进行递归，并且棋子减少一颗
            // 当前 i 来到第10层，扔下去没碎，(20 - 10) 就去 11 - 20层，更高的楼层去递归，棋子数目不变
            int yes = process1(i - 1, k - 1);
            // 如果没碎
            int no = process1(rest - i, k);
            min = Math.min(Math.max(yes, no), min);
        }
        // +1 是因为扔了这一次，才有的碎没碎这个答案
        return min + 1;
    }

    /**
     * dp[i][j] - 含义：还剩下的楼层对应的剩下的棋子数，扔了多少次
     * 楼层为0 无意义
     * 棋子数为0 无意义
     * 当还剩下一层楼，只需要扔一次棋子，所以dp[1][j] = 1
     * 还剩下一颗棋子，1层楼扔一次，2层楼扔2次，3层楼扔3次，所以du[i][1] = i的自然数列
     * 普遍位置的依赖，
     * 比如当前 [7,3] 还剩7层楼，还剩3颗棋子
     * 分析：
     * 1.第一次扔在第1层 碎了 0 ；                    没碎 还剩下6层楼，3颗棋子 [6,3]
     * 2.第一次扔在第2层 碎了 还剩下1层楼，2颗棋子[1,2]; 没碎 还剩下5层楼，3颗棋子 [5,3]
     * 3.第一次扔在第3层 碎了 还剩下2层楼，2颗棋子[2,2]; 没碎 还剩下4层楼，3颗棋子 [4,3]
     * 4.第一次扔在第4层 碎了 还剩下3层楼，2颗棋子[3,2]; 没碎 还剩下3层楼，3颗棋子 [3,3]
     * 5.第一次扔在第5层 碎了 还剩下4层楼，2颗棋子[4,2]; 没碎 还剩下2层楼，3颗棋子 [2,3]
     * 6.第一次扔在第6层 碎了 还剩下5层楼，2颗棋子[5,2]; 没碎 还剩下1层楼，3颗棋子 [1,3]
     * 7.第一次扔在第7层 碎了 还剩下6层楼，2颗棋子[6,2]; 没碎 答案是0；
     * 依赖自己的上方和自己前一列的上方位置
     * 既然这样，那么最右边的格子可以先求出来，因为每一个格子只依赖自己的上方，那么最右边的格子算出来后，
     * 其他的格子可以从依赖自己的上方变成上方和右方，因为最右方的格子很方便的算出来
     * 那么我的上方给我指导下限，右方给我指导上限，可以省略枚举行为
     */

    /**
     * 答案就是扔棋子的次数：
     * 固定棋子数：
     * 楼层 减少 答案  减少
     * 楼层 增加 答案  增加
     * 固定楼层：
     * 棋子 减少 答案  增加
     * 棋子 增加 答案  减少
     * 两个可变参数相对于答案而言是反向的关系
     */

    // 不使用四边形不等式优化，直接从上到下，从左到右填位置
    public static int superEggDrop2(int kChess, int nLevel) {
        if (kChess < 1 || nLevel < 1) {
            return 0;
        }
        if (kChess == 1) {
            return nLevel;
        }
        // 楼是行，棋子数是列
        int[][] dp = new int[nLevel + 1][kChess + 1];
        // 如果只有一颗棋子，有多少楼扔多少次，自然数序列
        for (int i = 1; i != dp.length; i++) {
            dp[i][1] = i;
        }
        // 普遍位置的依赖，右边和上边，那么先填右边的
        for (int i = 1; i != dp.length; i++) {
            for (int j = 2; j != dp[0].length; j++) {
                int min = Integer.MAX_VALUE;
                // 0层楼，无意义，所以从1开始枚举
                for (int k = 1; k != i + 1; k++) {

                    // 比如现在开始这个方法的时候rest总共20层楼，
                    // 当前 i 来到第10层，扔下去碎了，(10 - 1) 那么去 1 - 9层进行递归，并且棋子减少一颗
                    // 当前 i 来到第10层，扔下去没碎，(20 - 10) 就去 11 - 20层，更高的楼层去递归，棋子数目不变
                    // 如果碎了，去更低的楼层尝试，棋子数目少一个
                    int yes = dp[k - 1][j - 1];
                    // 如果没碎，去更高的楼层继续尝试，棋子数不变
                    int no = dp[i - k][j];
                    min = Math.min(min, Math.max(yes, no));
                }
                dp[i][j] = min + 1;
            }
        }
        return dp[kChess][nLevel];
    }


    // 使用四边形不等式，进行优化枚举行为，分析位置依赖，寻找指导位置
    public static int superEggDrop3(int kChess, int nLevel) {
        if (kChess < 1 || nLevel < 1) {
            return 0;
        }
        if (kChess == 1) {
            return nLevel;
        }
        // 楼是行，棋子数是列
        int[][] dp = new int[nLevel + 1][kChess + 1];
        // 最佳划分在哪一楼层，比如还剩下10层楼，还剩下3颗棋子，第一颗棋子扔在第7层得到了最优解，记载best中
        int[][] best = new int[nLevel + 1][kChess + 1];
        // 如果只有一颗棋子，有多少楼扔多少次，自然数序列
        for (int i = 1; i != dp.length; i++) {
            dp[i][1] = i;
        }
        // 只有1层楼，只需要扔一次
        for (int i = 1; i != dp[0].length; i++) {
            dp[1][i] = 1;
            // 只有一层楼，当然扔第一层
            best[1][i] = 1;
        }
        // 普遍位置的依赖，从第二层楼开始
        for (int i = 2; i < nLevel + 1; i++) {
            // 从右边往左边填，上右的位置对作为位置指导对
            for (int j = kChess; j > 1; j--) {
                int ans = Integer.MAX_VALUE;
                int bestIndex = -1;
                // 我的上边
                int down = best[i - 1][j];
                // 我的右边，如果是最右边了，没有指导位置，那么就需要这么多i楼层去尝试
                int up = j == kChess ? i : best[i][j + 1];
                // 0层楼，无意义，所以从1开始枚举
                for (int leftEnd = down; leftEnd <= up; leftEnd++) {
                    // 比如现在开始这个方法的时候rest总共20层楼，
                    // 当前 i 来到第10层，扔下去碎了，(10 - 1) 那么去 1 - 9层进行递归，并且棋子减少一颗
                    // 当前 i 来到第10层，扔下去没碎，(20 - 10) 就去 11 - 20层，更高的楼层去递归，棋子数目不变
                    // 如果碎了，去更低的楼层尝试，棋子数目少一个
                    int yes = dp[leftEnd - 1][j - 1];
                    // 如果没碎，去更高的楼层继续尝试，棋子数不变
                    int no = dp[i - leftEnd][j];
                    int cur = Math.min(yes, no);
                    // 是小于还等小于等于，不用区证明，直接对数器
                    if (cur <= ans) {
                        ans = cur;
                        bestIndex = leftEnd;
                    }
                }
                dp[i][j] = ans + 1;
                best[i][j] = bestIndex;
            }
        }
        return dp[kChess][nLevel];
    }

    // 最优解-假如10颗棋子扔10次能搞定多少层楼

    /**
     * dp [i][j] 表示 i颗棋子 扔j次，能搞定多少层楼，潜台词是，每次都是扔到最高层才碎的
     * 只扔一次，所以，那么楼层就是1
     * 只有一颗棋子，仍多少次，就是多少层楼
     * 使用数组压缩，一列一列的往后填，什么时候出现我们的楼层数，那么列数就是我们需要的答案
     * <p>
     * 格子依赖
     * 比如 现在已知
     * 6颗棋子扔9次可以解决50层楼的问题
     * 7颗棋子扔9次可以解决55层楼问题
     * 那么7颗棋子扔10次能解决多少层楼问题？？
     * 分析：如果第一次扔 x楼，
     * 碎了，还剩下9次，6颗棋子，下面的楼层继续区扔
     * 没碎，上面的格子去扔，就是还剩下7颗棋子，还可以扔9次，答案就是这两个之和+本次扔的这一次
     */
    public static int superEggDrop4(int kChess, int nLevel) {
        if (nLevel < 1 || kChess < 1) {
            return 0;
        }
        int[] dp = new int[kChess];
        int res = 0;
        // 一直从上往下填
        while (true) {
            // 左上格子
            int lastPre = 0;
            res++;
            //
            for (int i = 0; i < dp.length; i++) {
                // 自己的左边格子
                int pre = dp[i];
                dp[i] = pre + lastPre + 1;
                // 下一次列开始往下填的时候，记录上一次的格子，也就变成了当前的左上格子
                lastPre = pre;
                if (dp[i] >= kChess) {
                    return res;
                }
            }
        }
    }
}
